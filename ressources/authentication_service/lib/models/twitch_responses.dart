import 'dart:async';

import 'package:mutex/mutex.dart';

int _maxDownTime = 600; // seconds

class TwitchResponses {
  final _mutex = Mutex();

  ///
  /// Actual list of responses to be treated. The int is the stateToken, a
  /// random number generated by Twitch for each request so the request can
  /// be verified with a specific user. The String is the full response
  /// (including the state token) returned by Twitch.
  final Map<int, String> _responses = {};

  ///
  /// Test if a particular state token is waiting for a response
  bool containStateToken(int? stateToken) {
    return _responses.keys.contains(stateToken);
  }

  ///
  /// Get the specific stateToken clien info
  Future<String> pop(int stateToken) async {
    return await _mutex.protect(() async {
      final out = _responses[stateToken]!;
      print('Removed $stateToken (success)');
      _responses.remove(stateToken);
      return out;
    });
  }

  ///
  /// Add a new response to the list
  void add(String response) {
    _mutex.protect(() async {
      final re = RegExp(r'^.*&.*state=([0-9]*).*$');
      final match = re.firstMatch(response);
      final stateToken = int.parse(match!.group(1)!);

      _responses[stateToken] = response;
      print('Added state token $stateToken to the list');
      Timer(Duration(seconds: _maxDownTime),
          () => _removeUndealtResponse(stateToken));
    });
  }

  ///
  /// Make sure response that don't get treated are not there for ever
  void _removeUndealtResponse(int stateToken) {
    _mutex.protect(() async {
      if (_responses.containsKey(stateToken)) {
        print('Removed $stateToken (downtime)');
        _responses.remove(stateToken);
      }
    });
  }
}
